/**
 * @file runtime_frame_state.h
 * @brief Определяет макросы и функции для работы с состоянием фрейма выполнения.
 *
 * Этот файл содержит функции и макросы для управления состоянием фрейма выполнения
 * в контексте сохранения и восстановления выполнения программы с использованием
 * `setjmp` и `longjmp`.
 *
 * Он позволяет работать с контекстом выполнения на уровне фреймов,
 * что полезно для реализации механизма возврата к предыдущим состояниям
 * в многозадачных или асинхронных системах.
 *
 * Основные операции:
 * - Сохранение текущего состояния фрейма с использованием.
 * - Загрузка состояния фрейма и продолжение выполнения с использованием.
 * - Переход к следующему или предыдущему состоянию фрейма.
 * - Проверка на начало и конец состояний фреймов.
 *
 * Макросы и функции работают с типом `ae_jump_buffer_t`,
 * который представляет сохраненный контекст фрейма выполнения.
 *
 * Все операции поддерживают переходы между состояниями фрейма
 * и использование сохраненных контекстов для управления выполнением.
 */

#ifndef AE_RUNTIME_FRAME_STATE_H
#define AE_RUNTIME_FRAME_STATE_H

#include "jump_buffer.h"
#include "bool.h"

/**
 * @brief Сохраняет состояние фрейма выполнения.
 *
 * Макрос `ae_runtime_frame_state_save` сохраняет текущее состояние фрейма выполнения
 * в структуру `frame_state` и использует функцию `setjmp` для сохранения контекста.
 * Сначала макрос вызывает `ae_runtime_frame_state_push`, чтобы установить состояние
 * фрейма, а затем применяет `setjmp` для сохранения текущего состояния выполнения.
 *
 * @param frame_state Указатель на состояние фрейма,
 *                    которое будет сохранено.
 *
 * @note Этот макрос используется для сохранения контекста выполнения,
 *       чтобы можно было позже восстановить его с помощью `longjmp`.
 */
#define ae_runtime_frame_state_save(frame_state) setjmp(*ae_runtime_frame_state_push(frame_state))

/**
 * @brief Загружает предыдущее состояние фрейма выполнения и продолжает выполнение.
 *
 * Макрос `ae_runtime_frame_state_load` восстанавливает предыдущее состояние фрейма выполнения
 * с помощью функции `longjmp`, передавая значение `return_value`, которое будет использовано
 * для восстановления выполнения из точки, где было вызвано соответствующее сохранение
 * состояния с помощью `setjmp`.
 *
 * Сначала макрос вызывает `ae_runtime_frame_state_prev`, чтобы получить указатель
 * на предыдущее состояние фрейма, а затем передает его в `longjmp`,
 * чтобы продолжить выполнение с сохраненного контекста.
 *
 * @param return_value Значение, которое будет возвращено
 *                     при восстановлении контекста выполнения.
 *
 * @note Этот макрос используется для восстановления контекста выполнения,
 *       сохраненного с помощью `setjmp` и `ae_runtime_frame_state_push`,
 *       и позволяет продолжить выполнение программы с того места,
 *       где был сделан снимок состояния.
 */
#define ae_runtime_frame_state_load(return_value)                                                  \
    longjmp(*ae_runtime_frame_state_prev(), return_value)

/**
 * @brief Проверяет, находится ли выполнение в начале состояния фрейма.
 *
 * Функция `ae_runtime_frame_state_is_begin` проверяет, указывает ли указатель
 * `m_runtime_frame_state` на первый элемент массива `m_runtime_frame_states`,
 * что соответствует состоянию начала фрейма.
 *
 * Если указатель указывает на первый элемент массива,
 * функция возвращает `true`, в противном случае — `false`.
 *
 * @return `true`, если выполнение находится в начале состояния фрейма,
 *         и `false`, если в другом состоянии.
 */
bool
ae_runtime_frame_state_is_begin();

/**
 * @brief Проверяет, находится ли выполнение в конце состояния фрейма.
 *
 * Функция `ae_runtime_frame_state_is_end` проверяет, указывает ли указатель
 * `m_runtime_frame_state` на элемент массива `m_runtime_frame_states`, который
 * соответствует последнему состоянию фрейма.
 *
 * Если указатель указывает на элемент, находящийся за последним состоянием
 * (по индексу `ATL_RUNTIME_FRAME_STATE_MAX`), функция возвращает `true`,
 * в противном случае — `false`.
 *
 * @return `true`, если выполнение находится в конце состояния фрейма,
 *         и `false`, если в другом состоянии.
 */
bool
ae_runtime_frame_state_is_end();

/**
 * @brief Переходит к следующему состоянию фрейма выполнения.
 *
 * Функция `ae_runtime_frame_state_next` увеличивает указатель `m_runtime_frame_state`
 * на следующий элемент массива состояний фреймов, если текущее состояние не является
 * конечным (проверяется через функцию `ae_runtime_frame_state_is_end`).
 *
 * Если указатель не достиг конца массива, он увеличивается,
 * и возвращается указатель на следующее состояние.
 *
 * @return Указатель на следующее состояние фрейма типа `ae_jump_buffer_t`.
 *         Если текущее состояние является последним, возвращается значение
 *         текущего состояния.
 *
 * @note Если состояние фрейма находится в конце
 *       (когда `ae_runtime_frame_state_is_end()` возвращает `true`),
 *       то указатель не изменяется и возвращается текущее состояние.
 */
ae_jump_buffer_t *
ae_runtime_frame_state_next();

/**
 * @brief Переходит к предыдущему состоянию фрейма выполнения.
 *
 * Функция `ae_runtime_frame_state_prev` уменьшает указатель `m_runtime_frame_state`
 * на предыдущий элемент массива состояний фреймов, если текущее состояние не является
 * начальным (проверяется через функцию `ae_runtime_frame_state_is_begin`).
 *
 * Если указатель не достиг начала массива, он уменьшается,
 * и возвращается указатель на предыдущее состояние.
 *
 * @return Указатель на предыдущее состояние фрейма типа `ae_jump_buffer_t`.
 *         Если текущее состояние является первым, возвращается значение текущего состояния.
 *
 * @note Если состояние фрейма находится в начале
 *       (когда `ae_runtime_frame_state_is_begin()` возвращает `true`),
 *       то указатель не изменяется и возвращается текущее состояние.
 */
ae_jump_buffer_t *
ae_runtime_frame_state_prev();

/**
 * @brief Добавляет новое состояние фрейма и переходит к следующему состоянию.
 *
 * Функция `ae_runtime_frame_state_push` присваивает указатель на новое состояние фрейма
 * (параметр `frame_state`) текущему состоянию фрейма, а затем перемещает указатель
 * `m_runtime_frame_state` на следующее состояние фрейма с помощью функции
 * `ae_runtime_frame_state_next`. После этого возвращается указатель
 * на переданное состояние фрейма.
 *
 * @param frame_state Указатель на новое состояние фрейма типа `ae_jump_buffer_t`,
 *                    которое будет сохранено в текущем состоянии фрейма.
 *
 * @return Указатель на переданное состояние фрейма `frame_state`.
 */
ae_jump_buffer_t *
ae_runtime_frame_state_push(ae_jump_buffer_t *frame_state);

#endif // AE_RUNTIME_FRAME_STATE_H
