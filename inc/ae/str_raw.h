#ifndef AE_STR_RAW_H
#define AE_STR_RAW_H

#include "char.h"
#include "size.h"
#include "attribute.h"

/**
 * @def ae_str_raw_char_to
 * @brief Преобразует символ в указанный тип.
 *
 * Этот макрос выполняет преобразование символа в указанный тип данных.
 * Он позволяет безопасно преобразовывать значение типа `char` в другой тип,
 * указанный пользователем.
 *
 * @param T Тип, в который нужно преобразовать символ.
 * @param c Символ, который необходимо преобразовать.
 *
 * @return Преобразованное значение типа T.
 */
#define ae_str_raw_char_to(T, c) ((T)(c))

/**
 * @def ae_str_raw_char_to_int
 * @brief Преобразует символ в целое число типа ae_sint_t.
 *
 * Этот макрос преобразует символ в целое число с типом `ae_sint_t`
 * с использованием макроса `ae_str_raw_char_to`.
 *
 * Он обеспечивает преобразование символа
 * в целочисленное значение типа `ae_sint_t`.
 *
 * @param c Символ, который необходимо преобразовать.
 * @return Преобразованное значение типа `ae_sint_t`.
 */
#define ae_str_raw_char_to_int(c) ae_str_raw_char_to(ae_sint_t, c)

AE_COMPILER(EXTERN_C_BEGIN)

/**
 * @brief Находит первое вхождение указанного символа в строке.
 *
 * Эта функция ищет первое вхождение символа `value` в строке `str` длиной `str_len`.
 * Для выполнения операции используется функция @ref ae_memory_raw_find_value_u8,
 * которая находит значение в диапазоне памяти.
 *
 * Функция возвращает указатель на первое вхождение символа,
 * или `NULL`, если символ не найден.
 *
 * @param str Указатель на строку, в которой будет выполнен поиск.
 * @param str_len Длина строки `str`.
 * @param value Символ, который нужно найти в строке.
 *
 * @return Указатель на первое вхождение символа `value`
 *         в строке, или `NULL`, если символ не найден.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
const ae_char_t *
ae_str_raw_find_value_ex(const ae_char_t *str, ae_usize_t str_len, ae_char_t value);

/**
 * @brief Находит первое вхождение указанного символа в строке, не указывая её длину.
 *
 * Эта функция ищет первое вхождение символа `value` в строке `str`,
 * при этом длина строки автоматически вычисляется как разница между адресами.
 *
 * Для выполнения поиска используется функция @ref ae_str_raw_find_value_ex,
 * которая выполняет поиск в строке с заданной длиной.
 *
 * @param str Указатель на строку, в которой будет выполнен поиск.
 * @param value Символ, который нужно найти в строке.
 *
 * @return Указатель на первое вхождение символа `value`
 *         в строке, или `NULL`, если символ не найден.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
const ae_char_t *
ae_str_raw_find_value(const ae_char_t *str, ae_char_t value);

/**
 * @brief Находит первый нулевой терминатор в строке.
 *
 * Эта функция ищет первое вхождение нулевого терминатора (символа с кодом 0) в строке `str`.
 * Для этого используется функция @ref ae_str_raw_find_value,
 * которая выполняет поиск указанного символа (нулевого терминатора) в строке.
 *
 * @param str Указатель на строку,
 *            в которой будет выполнен поиск.
 *
 * @return Указатель на первое вхождение нулевого терминатора в строке,
 *         или `NULL`, если терминатор не найден.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
const ae_char_t *
ae_str_raw_find_null_terminator(const ae_char_t *str);

/**
 * @brief Вычисляет длину строки до первого нулевого терминатора.
 *
 * Эта функция находит первый нулевой терминатор в строке `str`
 * и вычисляет длину строки как разницу между адресами
 * первого нулевого терминатора и началом строки.
 *
 * Если строка не содержит нулевого терминатора, будет выброшено исключение.
 * Для поиска нулевого терминатора используется функция
 * @ref ae_str_raw_find_null_terminator.
 *
 * @param str Указатель на строку, длина которой должна быть вычислена.
 *
 * @return Длина строки в байтах (без учета нулевого терминатора).
 *
 * @throw AE_RUNTIME_ERROR_NO_NULL_TERMINATOR
 *        Если в строке не найден нулевой терминатор.
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_usize_t
ae_str_raw_len(const ae_char_t *str);

/**
 * @brief Копирует данные из исходной строки
 *        в целевую строку с заданной длиной.
 *
 * Эта функция выполняет копирование данных из строки `src`
 * в строку `str` на основе указанной длины `len`.
 *
 * Для выполнения операции используется функция @ref ae_memory_copy,
 * которая копирует данные из одного диапазона памяти в другой.
 *
 * После завершения копирования строка `str`
 * будет содержать данные из строки `src`.
 *
 * @param str Указатель на строку, в которую будут скопированы данные из исходной строки.
 * @param src Указатель на исходную строку, данные которой будут скопированы в `str`.
 * @param len Длина данных для копирования в байтах.
 *
 * @return Указатель на строку,
 *         содержащую данные после копирования.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c src является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_copy_ex(ae_char_t *str, const ae_char_t *src, ae_usize_t len);

/**
 * @brief Копирует данные из исходной строки в целевую строку.
 *
 * Эта функция выполняет копирование содержимого строки `src` в строку `str`.
 * Для выполнения операции используется функция @ref ae_str_raw_copy_ex,
 * которая выполняет фактическое копирование данных.
 *
 * После завершения копирования строка `str`
 * будет содержать данные из строки `src`.
 *
 * @param str Указатель на строку, в которую будут скопированы данные из исходной строки.
 * @param src Указатель на исходную строку, данные которой будут скопированы в `str`.
 *
 * @return Указатель на строку,
 *         содержащую данные после копирования.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c src является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_copy(ae_char_t *str, const ae_char_t *src);

/**
 * @brief Перемещает данные из исходной строки
 *        в целевую строку с заданной длиной.
 *
 * Эта функция выполняет перемещение данных из строки `src`
 * в строку `str` на основе указанной длины `len`.
 *
 * Для выполнения операции используется функция @ref ae_memory_move,
 * которая перемещает данные из одного диапазона памяти в другой.
 * После перемещения, строка `str` будет содержать данные из строки `src`.
 *
 * @param str Указатель на строку, в которую будут перемещены данные из исходной строки.
 * @param src Указатель на исходную строку, данные которой будут перемещены в `str`.
 * @param len Длина данных для перемещения в байтах.
 *
 * @return Указатель на строку,
 *         содержащую данные после перемещения.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c src является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_move_ex(ae_char_t *str, const ae_char_t *src, ae_usize_t len);

/**
 * @brief Перемещает данные из исходной строки в целевую строку.
 *
 * Эта функция выполняет перемещение содержимого строки `src` в строку `str`, заменяя её данные.
 * Для выполнения операции используется функция @ref ae_str_raw_move_ex, которая осуществляет
 * перемещение данных. После перемещения, строка `str` будет содержать данные из строки `src`,
 * а указатель на начало строки будет возвращён.
 *
 * @param str Указатель на строку, в которую будут перемещены данные из исходной строки.
 * @param src Указатель на исходную строку, данные которой будут перемещены в `str`.
 *
 * @return Указатель на строку,
 *         содержащую данные после перемещения.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c src является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_move(ae_char_t *str, const ae_char_t *src);

/**
 * @brief Добавляет строку из исходного диапазона в конец целевой строки.
 *
 * Эта функция вычисляет текущую длину целевой строки, а затем вызывает
 * @ref ae_memory_append_ex для добавления данных из исходной строки в конец целевой строки.
 * В результате целевая строка будет расширена данными из исходной строки.
 *
 * @param str Указатель на целевую строку, к которой будут добавлены данные.
 * @param src Указатель на начало исходной строки, данные которой будут добавлены.
 * @param src_len Длина исходной строки в байтах.
 *
 * @return Указатель на целевую строку после добавления данных.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c src является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_concat_ex(ae_char_t *str, const ae_char_t *src, ae_usize_t src_len);

/**
 * @brief Конкатенирует две строки (исходную и целевую),
 *        добавляя данные из исходной строки в конец целевой.
 *
 * Эта функция выполняет добавление содержимого строки `src` в конец строки `str`.
 * Для выполнения операции она использует функцию @ref ae_memory_append,
 * которая добавляет данные из одного диапазона памяти в другой.
 *
 * После завершения конкатенации, строка `str` будет содержать обе строки
 * в одном участке памяти, и указатель на начало этой строки будет возвращён.
 *
 * @param str Указатель на строку, к которой будут добавлены данные из исходной строки.
 * @param src Указатель на исходную строку, данные которой будут добавлены в `str`.
 *
 * @return Указатель на строку, содержащую результат конкатенации
 *         (совмещённое содержимое обеих строк).
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c src является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_concat(ae_char_t *str, const ae_char_t *src);

/**
 * @brief Очищает строку, заменяя её первый символ на нулевой терминатор.
 *
 * Эта функция принимает строку и заменяет её первый символ
 * на нулевой терминатор (NULL-терминатор).
 *
 * @param str Указатель на строку типа,
 *            которую необходимо очистить.
 *
 * @return Возвращает указатель на очищенную строку.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        В случае, если указатель на строку равен NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_clear(ae_char_t *str);

/**
 * @brief Сдвигает содержимое строки влево на заданное количество позиций
 *        и добавляет нулевой терминатор.
 *
 * Эта функция сдвигает содержимое строки `str` на `shift` позиций влево.
 * Если сдвиг больше или равен длине строки, то строка будет обрезана до первого символа,
 * а на его место будет записан нулевой терминатор.
 *
 * В противном случае сдвиг происходит с помощью функции @ref ae_memory_shift_left,
 * а после сдвига добавляется нулевой терминатор в конец строки.
 *
 * @param str Указатель на строку, которая будет сдвинута.
 * @param len Длина строки, которую необходимо сдвигать.
 * @param shift Количество позиций, на которое необходимо сдвигать строку влево.
 *
 * @return Указатель на строку после сдвига.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_shift_left_ex(ae_char_t *str, ae_usize_t len, ae_usize_t shift);

/**
 * @brief Сдвигает содержимое строки влево на заданное количество позиций.
 *
 * Эта функция сдвигает содержимое строки `str` влево на `shift` позиций.
 * Сначала вычисляется длина строки с помощью функции @ref ae_str_raw_len,
 * затем выполняется сдвиг с помощью функции @ref ae_str_raw_shift_left_with.
 *
 * @param str Указатель на строку, которая будет сдвинута.
 * @param shift Количество позиций, на которое необходимо сдвигать строку влево.
 *
 * @return Указатель на строку после сдвига.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 * @throw AE_RUNTIME_ERROR_NO_NULL_TERMINATOR
 *        Если в строке не найден нулевой терминатор.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_shift_left(ae_char_t *str, ae_usize_t shift);

/**
 * @brief Выполняет сдвиг строки вправо с заданным количеством символов
 *        и заполняет её указанным значением.
 *
 * Эта функция сдвигает строку вправо на указанное количество символов и заполняет
 * освободившееся пространство заданным значением. Если сдвиг больше или равен длине строки,
 * строка будет завершена нулевым символом. В случае успешного сдвига строка завершится
 * символом-терминатором.
 *
 * @param str Указатель на строку, которую нужно сдвигать.
 * @param len Длина строки, которую нужно обработать.
 * @param shift Количество символов, на которое нужно сдвигать строку вправо.
 * @param value Значение, которым будет заполнено освободившееся пространство после сдвига.
 *
 * @return Возвращает указатель
 *         на начало строки после выполнения сдвига и заполнения.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_shift_right_ex(ae_char_t *str, ae_usize_t len, ae_usize_t shift, ae_char_t value);

/**
 * @brief Выполняет сдвиг строки вправо
 *        с заданным количеством символов и заполняет её указанным значением.
 *
 * Эта функция сначала вычисляет длину строки с помощью @c ae_str_raw_len и затем вызывает
 * функцию @c ae_str_raw_shift_right_ex для выполнения сдвига строки вправо и заполнения
 * освободившегося пространства заданным значением.
 *
 * Если операция сдвига не может быть выполнена,
 * генерируется исключение.
 *
 * @param str Указатель на строку, которую нужно сдвигать.
 * @param shift Количество символов, на которое нужно сдвигать строку вправо.
 * @param value Значение, которым будет заполнено освободившееся пространство после сдвига.
 *
 * @return Возвращает указатель
 *         на начало строки после выполнения сдвига и заполнения.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_shift_right_with(ae_char_t *str, ae_usize_t shift, ae_char_t value);

/**
 * @brief Выполняет сдвиг строки вправо
 *        с заданным количеством символов и заполняет её пробелами.
 *
 * Эта функция вызывает @c ae_str_raw_shift_right_with,
 * передавая в качестве значения для заполнения пробел (символ @c AE_ASCII_MAP_SPACE).
 * Строка сдвигается вправо на указанное количество символов,
 * и освободившееся пространство заполняется пробелами.
 *
 * @param str Указатель на строку, которую нужно сдвигать.
 * @param shift Количество символов, на которое нужно сдвигать строку вправо.
 *
 * @return Возвращает указатель
 *         на начало строки после выполнения сдвига и заполнения пробелами.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 * @throw AE_RUNTIME_ERROR_INTERRUPTED
 *        Если операция сдвига была прервана.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_shift_right_with_space(ae_char_t *str, ae_usize_t shift);

/**
 * @brief Выполняет сдвиг строки вправо
 *        с заданным количеством символов и заполняет её пробелами.
 *
 * Эта функция вызывает @c ae_str_raw_shift_right_with_space для выполнения сдвига строки
 * вправо на указанное количество символов, заполняя освободившееся пространство пробелами.
 *
 * @param str Указатель на строку, которую нужно сдвигать.
 * @param shift Количество символов, на которое нужно сдвигать строку вправо.
 *
 * @return Возвращает указатель
 *         на начало строки после выполнения сдвига и заполнения пробелами.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_shift_right(ae_char_t *str, ae_usize_t shift);

/**
 * @brief Удаляет символы из начала строки, пока не встретится символ, не входящий в список.
 *
 * Эта функция сдвигает содержимое строки `str` влево,
 * удаляя символы из начала строки, которые присутствуют в массиве `characters`.
 * Процесс продолжается, пока не встретится символ, не входящий в список.
 * Сдвиг выполняется с помощью функции @ref ae_str_raw_shift_left_with.
 *
 * @param str Указатель на строку, из которой необходимо удалить символы с начала.
 * @param len Длина строки, из которой будет удалены символы.
 * @param characters Массив символов, которые будут удалены с начала строки.
 *
 * @return Указатель на строку после удаления символов.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 * @throw AE_RUNTIME_ERROR_NO_NULL_TERMINATOR
 *        Если в строке не найден нулевой терминатор.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_left_with(ae_char_t *str, ae_usize_t len, const ae_char_t characters[]);

/**
 * @brief Удаляет символы из начала строки,
 *        пока не встретится символ, не входящий в список.
 *
 * Эта функция вычисляет длину строки с помощью функции @ref ae_str_raw_len и затем вызывает
 * функцию @ref ae_str_raw_trim_left_with для удаления символов из начала строки,
 * которые присутствуют в массиве `characters`.
 *
 * Процесс продолжается до тех пор, пока не будет найден символ,
 * который не входит в этот список.
 *
 * @param str Указатель на строку, из которой необходимо удалить символы с начала.
 * @param characters Массив символов, которые будут удалены с начала строки.
 *
 * @return Указатель на строку после удаления символов.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 * @throw AE_RUNTIME_ERROR_NO_NULL_TERMINATOR
 *        Если в строке не найден нулевой терминатор.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_left_ex(ae_char_t *str, const ae_char_t characters[]);

/**
 * @brief Удаляет пробельные символы и символы новой строки с начала строки.
 *
 * Эта функция использует функцию @ref ae_str_raw_trim_left_for для удаления всех пробельных
 * символов и символов новой строки (включая пробел, символы новой строки, возврата каретки,
 * табуляции и вертикальной табуляции) с начала строки.
 *
 * Символы, которые подлежат удалению, определяются в статическом массиве @ref m_trim_ascii_chars.
 * После выполнения обрезки возвращается указатель на строку.
 *
 * @param str Указатель на строку,
 *            из которой необходимо удалить пробельные символы с начала.
 *
 * @return Указатель на строку после удаления символов.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 * @throw AE_RUNTIME_ERROR_NO_NULL_TERMINATOR
 *        Если в строке не найден нулевой терминатор.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_left(ae_char_t *str);

/**
 * @brief Обрезает символы справа от строки,
 *        если они совпадают с одним из указанных символов.
 *
 * Эта функция удаляет символы из конца строки, если они присутствуют в массиве символов @c
 * characters. Строка обрезается до первого символа, который не находится в этом массиве.
 * Операция завершается установкой символа-терминатора в конец строки.
 *
 * @param str Указатель на строку, которую нужно обрезать.
 * @param len Длина строки, которую нужно обработать.
 * @param characters Массив символов, которые будут удалены с конца строки.
 *
 * @return Возвращает указатель на начало строки после обрезания.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c characters является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_right_with(ae_char_t *str, ae_usize_t len, const ae_char_t characters[]);

/**
 * @brief Обрезает символы справа от строки,
 *        если они совпадают с одним из указанных символов.
 *
 * Эта функция вычисляет длину строки с помощью @c ae_str_raw_len и затем вызывает
 * функцию @c ae_str_raw_trim_right_with для удаления символов с конца строки,
 * если они находятся в массиве символов @c characters.
 *
 * @param str Указатель на строку, которую нужно обрезать.
 * @param characters Массив символов, которые будут удалены с конца строки.
 *
 * @return Возвращает указатель на начало строки после обрезания.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c characters является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_right_ex(ae_char_t *str, const ae_char_t characters[]);

/**
 * @brief Обрезает пробельные символы и символы управления справа от строки.
 *
 * Эта функция вызывает @c ae_str_raw_trim_right_ex для удаления пробельных символов и символов
 * управления (пробел, новая строка, возврат каретки, табуляция, вертикальная табуляция и символ
 * окончания строки) с конца строки.
 *
 * @param str Указатель на строку, которую нужно обрезать.
 * @return Возвращает указатель на начало строки после обрезания.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_right(ae_char_t *str);

/**
 * @brief Обрезает указанные символы с обеих сторон строки.
 *
 * Эта функция вызывает @c ae_str_raw_trim_left_ex для удаления указанных символов
 * с начала строки и затем вызывает @c ae_str_raw_trim_right_ex для удаления
 * тех же символов с конца строки.
 *
 * @param str Указатель на строку, которую нужно обрезать.
 * @param characters Массив символов, которые будут удалены с обеих сторон строки.
 *
 * @return Возвращает указатель на начало строки после обрезания.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str или @c characters является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim_ex(ae_char_t *str, const ae_char_t characters[]);

/**
 * @brief Обрезает пробельные символы и символы управления с обеих сторон строки.
 *
 * Эта функция вызывает @c ae_str_raw_trim_ex для удаления пробельных символов и символов
 * управления (пробел, новая строка, возврат каретки, табуляция, вертикальная табуляция
 * и символ окончания строки) с обеих сторон строки.
 *
 * @param str Указатель на строку, которую нужно обрезать.
 * @return Возвращает указатель на начало строки после обрезания.
 *
 * @throw AE_RUNTIME_ERROR_NULL_POINTER
 *        Если @c str является NULL.
 */
AE_ATTRIBUTE(SYMBOL)
ae_char_t *
ae_str_raw_trim(ae_char_t *str);

AE_COMPILER(EXTERN_C_END)

#endif // AE_STR_RAW_H
